1. 索引树高度影响因素
   1. 索引字段较长-使用前缀索引
   2. 数据行过多-分区表、归档表(pt-archive)、分布式
   3. 数据类型-使用合适的数据类型
2. 什么时候建索引：将索引建在经常where、group by、order by、join on的条件上
3. 为什么不能乱建：
   1. 冗余索引过多，数据频繁变化会导致索引频繁更新，会阻塞正常业务
   2. 会导致优化器选择出错
4. 索引命令
   1. 查看表索引：`show index from tb_item`
      1. pri：聚簇索引
      2. mul：辅助索引
      3. uni：唯一索引
   2. 建立索引：`alter table # add index idx(#)`
      1. 联合索引：`alter table # add index idx(#1,#2)`
      2. 前缀索引：`alter table # add index idx(#1(5))`
   3. 删除索引：`alter table # drop index idx`
# 1. 聚簇索引
1. 生成
   1. 指定主键时，innodb将主键作为聚簇索引
   2. 未指定主键时，自动选择unique列作为聚簇索引
   3. 以上都没有，自动生成隐藏聚簇索引
2. 作用
   1. 按照ID的顺序，在磁盘有序存储
# 2. 辅助索引
1. 生成
   1. 手动创建`alter table # add index idx(#)`
2. 作用
   1. 使用普通列作为索引
   2. 优化非聚簇索引之外的条件
3. 回表：在辅助索引建立的索引表查找后，回来聚簇索引的索引表中继续查找
4. 索引类型
   1. 单列
   2. 联合：`alter table # add index idx(#1,#2,#3)`
      1. 建立索引表时，会选择最左列的索引`#1`存储
      2. 全覆盖：查询了联合索引的所有字段
      3. 部分覆盖：查询了联合索引中索引组合的字段(#1,#1#2,#1#2#3)
   3. 前缀
# 3. 优化
1. 联合索引创建时，重复值少的列放在最左列
2. 联合索引查询时
   1. 走索引
      1. 查询字段必须带有索引的最左侧字段
      2. where #1 order #2
   2. 不走索引
      1. 不等式查询及后续的条件无法使用索引：大于、小于、大于等于、小于等于、like
# 4. 执行计划
1. 查看执行计划：`explain {sql}`或`desc {sql}`
2. 执行计划详解：
   1. table：查询涉及的表
   2. type：查询类型
      1. 全表扫描：all
      2. 索引扫描：index < range < ref < eq_ref < const(system)
         1. index：索引树全扫描
         2. range：索引范围查询，如大于、小于、like、in、or、between and、union all
         3. ref：辅助索引等值查询
         4. eq_ref：join时，非驱动表链接条件是主键或唯一键
         5. const(system)：聚簇索引等值查询
   3. possible_keys：可能用到的索引，即和此次查询相关的索引
   4. key：实际使用的索引
   5. key_len：联合索引的覆盖长度
TODO 65 09:07
   6. rows：查询扫描的行数