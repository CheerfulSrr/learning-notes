1. 索引树高度影响因素
   1. 索引字段较长-使用前缀索引
   2. 数据行过多-分区表、归档表(pt-archive)、分布式
   3. 数据类型-使用合适的数据类型
2. 什么时候建索引：将索引建在经常where、group by、order by、join on的条件上
3. 为什么不能乱建：
   1. 冗余索引过多，数据频繁变化会导致索引频繁更新，会阻塞正常业务
   2. 会导致优化器选择出错
4. 索引命令
   1. 查看表索引：`show index from tb_item`
      1. pri：聚簇索引
      2. mul：辅助索引
      3. uni：唯一索引
   2. 建立索引：`alter table # add index idx(#)`
      1. 联合索引：`alter table # add index idx(#1,#2)`
      2. 前缀索引：`alter table # add index idx(#1(5))`
   3. 删除索引：`alter table # drop index idx`
5. 执行计划
TODO P63
# 1. 聚簇索引
1. 生成
   1. 指定主键时，innodb将主键作为聚簇索引
   2. 未指定主键时，自动选择unique列作为聚簇索引
   3. 以上都没有，自动生成隐藏聚簇索引
2. 作用
   1. 按照ID的顺序，在磁盘有序存储
# 2. 辅助索引
1. 生成
   1. 手动创建`alter table # add index idx(#)`
2. 作用
   1. 使用普通列作为索引
   2. 优化非聚簇索引之外的条件
3. 回表：在辅助索引建立的索引表查找后，回来聚簇索引的索引表中继续查找
4. 索引类型
   1. 单列
   2. 联合：`alter table # add index idx(#1,#2,#3)`
      1. 建立索引表时，会选择最左列的索引`#1`存储
      2. 全覆盖：查询了联合索引的所有字段
      3. 部分覆盖：查询了联合索引中索引组合的字段(#1,#1#2,#1#2#3)
   3. 前缀
# 3. 优化
1. 联合索引创建时，重复值少的列放在最左列
2. 联合索引查询时
   1. 走索引
      1. 查询字段必须带有索引的最左侧字段
      2. where #1 order #2
   2. 不走索引
      1. 不等式查询及后续的条件无法使用索引：大于、小于、大于等于、小于等于、like
