> `tcp`：基于`流`的`长连接`的数据传递，发送的数据带有`顺序性`  
> `tcp`：是一种流协议，以流为单位进行数据传递  
> `短连接`：`短连接`是当服务端与客户端连接成功后开始传输数据，传输完毕后立即关闭连接。再次传输数据需要建立新的连接   
> `长连接`：`长连接`是服务端与客户端进行3次握手后，进行多次通信。`长连接`就是复用当前的连接以达到多次通信的目的  
1. `短连接`优缺点：
   * 优点：不需要保存`socket`对象，降低内存使用率
   * 缺点：每次都要进行三次握手，增加处理时间
2. `长连接`优缺点：
   * 优点：复用连接提高程序运行效率
   * 缺点：在服务端保存多个`socket`对象，占用服务端资源
# 1. 基于`tcp`的`Socket`通信
1. 3次握手
# 2. `tcp`的握手过程
# 3. `ServerSocket`
1. 创建服务端
## 3.1. 构造方法
1. ```ServerSocket(int port, int backlog, InetAddress bindAddr)```
   * `port`：端口
   * `backlog`：允许接受客户端连接请求的个数，默认50
   * `bindAddr`：指定客户端IP
       1. 默认为`0.0.0.0`
       2. 客户端初始化连接时，IP地址必须与`bindAddr`相同(`bindAddr`不为空时)
## 3.2. 方法
1. `accept()`: 侦听并接受套接字的连接，阻塞当前连接，返回`Socket`实例
2. 设置超时：```synchronized void setSoTimeout(int timeout)```
2. 绑定IP地址与端口：```void bind(SocketAddress endpoint, int backlog)```
2. 获得本地`SocketAddress`对象：`SocketAddress getLocalSocketAddress()`
2. 获得绑定的端口：`int getLocalPort()`
2. `inputStream.close()`: 关闭`steam`的同时也关闭了`Socket`
2. 关闭：`void close()`，所有阻塞的线程抛出`SocketException`
2. 判断是否关闭：`boolean isClosed()`，已经关闭则返回`true`
2. 端口复用：
   * 如果启用，主动关闭套接字连接的一方会进入`TIME_WAIT`状态，再”停留若干时间“，进入`CLOSED`状态。
   * 在”停留若干时间“内，程序可以使用`TIME_WAIT`状态的端口
   * 需在`bind()`之前开启
   * 开启端口复用：`void setReuseAddress(boolean on)`
   * 查看是否启用：`boolean getReuseAddress()`
2. 修改`SO_RCVBUF`
![](./images/socket/win.png)
   * `SO_RCVBUF`是内部套接字接收缓冲区的大小、公布到远程同位体的TCP接收窗口(`win=66`)的大小
   * 需在`bind()`之前开启
## 3.e 相关类
1. `SocketAddress`  
![](./images/socket/SocketAddress.png)
   * ```InetSocketAddress(int port)```：传入端口创建套接字地址，传0时随机选择端口
   * ```InetSocketAddress(InetAddress addr, int port)```：根据IP地址与端口号创建套接字地址
   * ```InetSocketAddress(String hostname, int port)```：根据主机名与端口号创建套接字地址
# 4. `Socket`
1. 创建客户端。客户端需主动连接服务端
## 4.1. 方法
1. `getInputStream()`: 从输入流中获取数据，阻塞当前连接
